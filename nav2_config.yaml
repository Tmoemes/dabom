# nav2_params.yaml
amcl:
  ros__parameters:
    use_sim_time: false
    alpha1: 0.2
    alpha2: 0.2
    alpha3: 0.2
    alpha4: 0.2
    alpha5: 0.1
    base_frame_id: "base_link"
    odom_frame_id: "odom"
    scan_topic: "scan"
    robot_model_type: "nav2_amcl::OmniMotionModel"  # Should be adapted for your robot's kinematic model
    # percetange of beams to force full update of map
    beam_skip_error_threshold: 0.8
    # Percetang of beams required to skip
    beam_skip_threshold: 0.3
    do_beam_skip: False
    global_frame_id: "map"
    # Decay parameter for z_short part of the model
    lambda_short: 0.1
    # max distance for obstacle inflation on map
    lasaer_likelihood_max_dist: 2.0
    laser_max_range: 100.0
    laser_min_range: -1
    # Use "likelihood_field_prob" when beam skipping
    laser_model_type: "likelihood_field"
    set_initial_pose: False
    # initial_pose: [0.0, 0.0, 0.0, 0.0]
    # How many beams to use in update filter
    max_beams: 60
    min_particles: 500
    max_particles: 2000
    pf_err: 0.05
    # Particle filter population desinty
    pf_z: 0.99
    # Exponential decay rate for fast average wieght filted used to decide whe nto add random pose a good value might be 0.1
    recovery_alpha_fast: 0.1
    # Exponential decay rate for slow average wieght filted used to decide whe nto add random pose a good value might be 000.1
    recovery_alpha_slow: 0.001
    # samples needed before updating
    resample_interval: 1
    # when to save pos for next run?
    save_pose_rate: 0.5
    # std for gaussian model used in z-hit part of the model
    sigma_hit: 0.2
    # Broadcasts the transfor mbetwee n global frame and odom frame
    tf_broadcast: True
    # Time with which to post-date the transform that is published, to indicate that this transform is valid into the future.T
    transform_tolerance: 0.1
    # Rotational movement needed before filter update
    update_min_a: 0.1
    # translation before filter update
    update_min_d: 0.1
    # mixture wieghts for the z? part of the model
    # z-hit prt of model
    z_hit: 0.5
    z_max: 0.05
    z_rand: 0.5
    z_short: 0.005
    # if true provide acml with initial pose
    always_reset_initial_pose: False
    # accepts more then once on the map topic
    first_map_only: False
    # Lifecycle node bond mechanism
    bond_heart_period: 0.1


map_server:
  ros__parameters:
    use_sim_time: false
    # Should be bogus see map server parameters
    resolution: 0.05
  
costmap_filter_info_server:
  costmap_filter_info_server:
    ros__parameters:
      # Type of cost map filter used
      # 0 keepout zones
      # 1 speef filter, speed limit is in % maximum speedo
      # 2 speed filter, speed limit is specified in abs value (m/s)
      # 3. binary filter
      type: 0
      filter_info_topic: "costmap_filter_info"
      mask_topic: "filter_mask"
      # filter_sapce_value = base + mult * mask_value
      base: 0.0
      multiplier: 0.25 

planner_server:
  ros__parameters:
    # Frquency of planner update if current freq < expected print warning
    expected_planner_frequency: 20.0
    # After this many seconds timeout action
    action_server_result_timeout: 10.0
    GridBased:
      plugin: "nav2_navfn_planner/NavfnPlanner"
      use_astart: True
      use_final_approach_orientation: false
      # Toleracne in meter between goal pose and end path
      tolerance: 0.5

controller_server:
  ros__parameters:
    use_sim_time: false
    # Frequency to run controller at
    controller_frequency: 20.0
    # use realtime priority elevates the priority of the controller process to give it more compute
    use_realtime_priority: false
    publish_zero_velocity: true
    action_server_result_timeout: 10.0

    # Each plugin defined here has to have ahve a parameter list define
    controller_plugins: ["FollowPath"]
    FollowPath:
      plugin: "dwb_core/DWBLocalPlanner"
      # use_velocity_scaled_lookahead_dist: true
      # lookahead_dist: 0.5
      # max_lookahead_dist: 2.0
      # min_lookahead_dist: 0.3
      # max_allowed_time_to_collision: 1.0
      # regulate_linear_velocity: true
      # use_regulated_linear_velocity_scaling: true
      # use_cost_regulated_linear_velocity_scaling: false
      # transform_tolerance: 0.2

    progress_checker_plugin: ["progress_checker"]
    progress_checker:
      plugin: "nav2_controller/SimpleProgressChecker"
      # Minimum the robot has the move
      required_movement_radius: 0.5
      # max amount of time a robot has to move the minimum radius
      movement_time_allowance: 10.0

    goal_checker_plugin: ["goal_checker"]
    goal_checker:
      plugin: "nav2_controller/SimpleGoalChecker"
      # tolerance to meet goal completion in m
      xy_goal_tolerance: 0.25
      # rad
      yaw_goal_tolerance: 0.25
      # Check xy positino tolerance after goal roientatione
      stateful: true

    min_x_velocity_threshold: 0.1
    miny_y_velocity_threshold: 0.1
    min_theta_velocity_threshold: 0.1
    # Max duration in seconds for the follow path action fails
    failure_tolerance: 1.0

    odom_topic: "odom"
    enable_stamped_cmd_vel: false

global_costmap:
  global_costmap:
    ros__parameters:
      always_send_full_costmap: false
      footprint_padding: 0.01
      footprint: [[0.15, 0.15], [0.15, -0.15], [-0.15, -0.15], [-0.15, 0.15]]
      global_frame: "map"
      # Height of cost map? (m)
      height: 5
      width: 5
      # minimum cost of an occupancy grid
      lethal_cost_threshold: 100
      map_topic: "map"
      # The height of map, allows to avoid rviz visualization flickering at -0.008 (What does this even mean)
      map_vis_z: 0.0
      # To be used when not specified in plugin?
      observation_sources: ""
      # origin o fthe cost map
      origin_x: 0.0
      origin_y: 0.0
      publish_frequency: 1.0
      # Resolution of 1 pixel of the costmap in meters, thus 1 pixel = 0.1m
      resolution: 0.1
      # We should not use this since we defined the footprint
      #robot_radius: 0.1
      # Should the costmap roll with the robot base frame???
      rolling_window: False
      # if false treats unkown space as free space else unkown space
      track_unknown_space: False
      # TF transform tolerance no clue what does
      transform_tolerance: 0.3
      # Time to wait before base frame -> global frame becomes availble
      initial_transform_timeout: 60.0
      # interpret the costmap as three values free, occupied unknwon or with stored values
      trinary_costmap: True
      # cost of unkown value if tracking
      unkown_cost_value: 255
      update_frequency: 5.0
      # Use the maximum when combining costmaps false default
      use_maximum: False
      # static layer inflatino layer, obstacle layer, voxel layer, range sensor denoise plugins
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
      # Static lyaer a costmap layer from SLAM
      static_layer:
        plugin: "nav2_costmap_2d/StaticLayer"
        enabled: True
        # Clear occupied cells under robot footprint
        footprint_clearing_enabled: False
        # Subscribe to statpic map udpates after receiving
        subscribe_to_updates: False
        # QOS setting for map tpoic
        map_subscribe_transient_local: True
        transform_tolerance: 0.0
        map_topic: "map"
      # costmap laye pluing uses 2d raycasting for 2dlidars
      obstacle_layer:
        plugin: "nav2_costmap_2d/ObstacleLayer"
        enabled: True
        footprint_clearing_enabled: True
        # max height to add return to occupancy grid
        max_obstacle_height: 2.0
        # Combination method
        # 0 overwrite master costmap with every valid observation
        # 1 max set max of the two
        # 2 - MaxWithoutUnknownOverwrite: Sets the new value to the maximum of the master_grid’s
        # value and this layer’s value. If the master value is NO_INFORMATION, it is NOT overwritten.
        # It can be used to make sure that the static map is the dominant source of information, and
        # prevent the robot to go through places that are not present in the static map.
        combination_method: 1
        # namespace for osbservation source
        # TODO SHOULD PROBABLY LOOK AT THIS IF THIS IS CORRECT!!!!!!!!
        observation_sources: scan
        scan: 
          topic: "/scan"
          #sensor_frame:
          # How long to store messages in buffer to process in cost mape
          observation_persistence: 0.0
          #expected_update_rate <- no clear description of what and how
          data_type: "LaserScan"
          # min height to add to return to occup grid
          min_obstacle_height: 0.0
          max_obstacle_height: 0.0
          inf_is_valid: False
          # Source marking in map
          marking: True
          # Wether source should raytrace clear in costmap <- no clue what this means <- use raytracing to clear obstacles with laser scan
          clearing: True # default False

      inflation_layer:
        plugin: "nav2_costmap_2d/InflationLayer"

      

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 2.0
      global_frame: "odom"
      robot_base_frame: "base_link"
      rolling_window: true
      width: 3.0
      height: 3.0
      resolution: 0.05
      plugins: ["obstacle_layer", "inflation_layer"]

      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: true
        observation_sources: scan
        scan:
          topic: scan
          max_obstacle_height: 2.0
          obstacle_range: 2.5
          raytrace_range: 3.0
          clearing: true
          marking: true

      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        inflation_radius: 0.55
        cost_scaling_factor: 10.0


bt_navigator:
  ros__parameters:
    use_sim_time: false
    bt_xml_filename: "path/to/navigate_w_replanning_and_recovery.xml"

waypoint_follower:
  ros__parameters:
    use_sim_time: false
    waypoint_follower_plugin: "nav2_waypoint_follower::WaypointFollower"

robot_description:
  ros__parameters:
    use_sim_time: false
    urdf: "path/to/robot.urdf"

# Parameters for the holonomic mecanum drive controller (assuming you're using diff_drive_controller)
mecanum_controller:
  ros__parameters:
    type: "mecanum_drive_controller/MecanumDriveController"
    publish_rate: 50
    twist_topic: "cmd_vel"
    odom_topic: "odom"
    base_frame_id: "base_link"
    enable_odom_tf: true
    publish_cmd: true
    wheel_radius: 0.05
    wheel_separation: 0.3
    wheel_base: 0.3
    front_left_wheel: "front_left_wheel_joint"
    front_right_wheel: "front_right_wheel_joint"
    rear_left_wheel: "rear_left_wheel_joint"
    rear_right_wheel: "rear_right_wheel_joint"
    velocity_rolling_window_size: 10
    cmd_vel_timeout: 0.25
